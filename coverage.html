
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kalpovskii/checklist/cmd/api/main.go (46.7%)</option>
				
				<option value="file1">github.com/kalpovskii/checklist/cmd/db/main.go (47.2%)</option>
				
				<option value="file2">github.com/kalpovskii/checklist/cmd/kafka-logger/main.go (0.0%)</option>
				
				<option value="file3">github.com/kalpovskii/checklist/internal/app/pb/task.pb.go (0.0%)</option>
				
				<option value="file4">github.com/kalpovskii/checklist/internal/app/pb/task_grpc.pb.go (0.0%)</option>
				
				<option value="file5">github.com/kalpovskii/checklist/internal/app/repositories/postgres.go (0.0%)</option>
				
				<option value="file6">github.com/kalpovskii/checklist/internal/app/repositories/redis.go (0.0%)</option>
				
				<option value="file7">github.com/kalpovskii/checklist/internal/app/services/task.go (0.0%)</option>
				
				<option value="file8">github.com/kalpovskii/checklist/internal/kafka/producer.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log"
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/kalpovskii/checklist/internal/app/pb"
        "github.com/kalpovskii/checklist/internal/kafka"
        "github.com/spf13/viper"
        "google.golang.org/grpc"
        "google.golang.org/protobuf/types/known/emptypb"
)

var taskClient pb.TaskServiceClient

func initConfig() <span class="cov0" title="0">{
        viper.SetEnvPrefix("CHECKLIST")
        viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        viper.AutomaticEnv()
}</span>

func main() <span class="cov0" title="0">{
        initConfig()

  grpcURL := viper.GetString("DB_GRPC_URL")
  apiPort := viper.GetString("API_PORT")
        // initializing kafka
        kafkaBroker := viper.GetString("KAFKA_BROKER")
        kafkaTopic := viper.GetString("KAFKA_TOPIC")

        if apiPort == "" || grpcURL == "" </span><span class="cov0" title="0">{
                log.Fatal("API_PORT or DB_GRPC_URL is not configured")
        }</span>

        // connect to gRPC server
        <span class="cov0" title="0">conn, err := grpc.Dial(grpcURL, grpc.WithInsecure())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect to gRPC server: %v", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        taskClient = pb.NewTaskServiceClient(conn)

        // create kafka producer
        producer := kafka.NewProducer(kafkaBroker, kafkaTopic)

        log.Printf("API started on :%s", apiPort)
        log.Printf("Connected to gRPC DB at %s", grpcURL)
        log.Printf("Kafka producer connected to %s topic %s", kafkaBroker, kafkaTopic)

        r := gin.Default()

        r.POST("/create", func(c *gin.Context) </span><span class="cov0" title="0">{createHandler(c, producer)}</span>)
        <span class="cov0" title="0">r.GET("/list", func(c *gin.Context) </span><span class="cov0" title="0">{ listHandler(c, producer) }</span>)
        <span class="cov0" title="0">r.DELETE("/delete", func(c *gin.Context) </span><span class="cov0" title="0">{ deleteHandler(c, producer) }</span>)
        <span class="cov0" title="0">r.PUT("/done", func(c *gin.Context) </span><span class="cov0" title="0">{ doneHandler(c, producer) }</span>)

        <span class="cov0" title="0">log.Fatal(r.Run(":" + apiPort))</span>
}

func sendKafkaEvent(producer *kafka.Producer, action string) <span class="cov8" title="1">{
        if producer != nil </span><span class="cov0" title="0">{
                producer.SendEvent(action)
        }</span>
}

func createHandler(c *gin.Context, producer *kafka.Producer) <span class="cov8" title="1">{
        var req struct {
                Title   string `json:"title"`
                Content string `json:"content"`
        }
        if err := c.BindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        res, err := taskClient.Create(ctx, &amp;pb.CreateTaskRequest{
                Title:   req.Title,
                Content: req.Content,
        })
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">sendKafkaEvent(producer, "create")

        c.JSON(http.StatusOK, res.Task)</span>
}

func listHandler(c *gin.Context, producer *kafka.Producer) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        res, err := taskClient.List(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">sendKafkaEvent(producer, "list")

        c.JSON(http.StatusOK, res.Tasks)</span>
}

func deleteHandler(c *gin.Context, producer *kafka.Producer) <span class="cov8" title="1">{
        var req struct {
                ID string `json:"id"`
        }
        if err := c.BindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        res, err := taskClient.Delete(ctx, &amp;pb.TaskIDRequest{Id: req.ID})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">sendKafkaEvent(producer, "delete")

        c.JSON(http.StatusOK, res)</span>
}

func doneHandler(c *gin.Context, producer *kafka.Producer) <span class="cov8" title="1">{
        var req struct {
                ID string `json:"id"`
        }
        if err := c.BindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        res, err := taskClient.MarkDone(ctx, &amp;pb.TaskIDRequest{Id: req.ID})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">sendKafkaEvent(producer, "mark_done")

        c.JSON(http.StatusOK, res)</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "log"
        "net"
        "time"

        "github.com/google/uuid"
        "github.com/kalpovskii/checklist/internal/app/pb"
        "github.com/kalpovskii/checklist/internal/app/repositories"
        "github.com/kalpovskii/checklist/internal/app/services"
        "github.com/redis/go-redis/v9"
        "github.com/spf13/viper"
        "google.golang.org/grpc"
        "google.golang.org/protobuf/types/known/emptypb"
        "google.golang.org/protobuf/types/known/timestamppb"
)

type TaskServer struct {
        pb.UnimplementedTaskServiceServer
        service *services.TaskService
}

func (s *TaskServer) Create(ctx context.Context, req *pb.CreateTaskRequest) (*pb.TaskResponse, error) <span class="cov8" title="1">{
        task, err := s.service.Create(req.Title, req.Content)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;pb.TaskResponse{
                Task: &amp;pb.Task{
                        Id:        task.ID.String(),
                        Title:     task.Title,
                        Content:   task.Content,
                        Done:      task.Done,
                        CreatedAt: timestamppb.New(task.CreatedAt),
                },
        }, nil</span>
}

func (s *TaskServer) List(ctx context.Context, req *emptypb.Empty) (*pb.TaskListResponse, error) <span class="cov8" title="1">{
    tasks, err := s.service.List()
    if err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>

    <span class="cov8" title="1">resp := &amp;pb.TaskListResponse{}
    for _, t := range tasks </span><span class="cov8" title="1">{
        resp.Tasks = append(resp.Tasks, &amp;pb.Task{
            Id:        t.ID.String(),
            Title:     t.Title,
            Content:   t.Content,
            Done:      t.Done,
            CreatedAt: timestamppb.New(t.CreatedAt),
        })
    }</span>
    <span class="cov8" title="1">return resp, nil</span>
}

func (s *TaskServer) Delete(ctx context.Context, req *pb.TaskIDRequest) (*pb.StatusResponse, error) <span class="cov8" title="1">{
        id, err := uuid.Parse(req.Id)
  if err != nil </span><span class="cov8" title="1">{
      return nil, err
        }</span>
        
        <span class="cov8" title="1">err = s.service.Delete(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;pb.StatusResponse{Status: "deleted"}, nil</span>
}

func (s *TaskServer) MarkDone(ctx context.Context, req *pb.TaskIDRequest) (*pb.StatusResponse, error) <span class="cov8" title="1">{
        id, err := uuid.Parse(req.Id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = s.service.MarkDone(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;pb.StatusResponse{Status: "done"}, nil</span>
}

func main() <span class="cov0" title="0">{
        viper.SetEnvPrefix("CHECKLIST")
        viper.AutomaticEnv()

        redisAddr := viper.GetString("REDIS_ADDR")
        if redisAddr == "" </span><span class="cov0" title="0">{
                log.Fatal("REDIS_ADDR is not configured")
        }</span>
        <span class="cov0" title="0">port := viper.GetString("DB_GRPC_PORT")
  dsn  := viper.GetString("DB_POSTGRES_DSN")
        if dsn == "" || port == "" </span><span class="cov0" title="0">{
                log.Fatal("DB_POSTGRES_DSN or DB_GRPC_PORT is not configured")
        }</span>

        <span class="cov0" title="0">repo, err := repositories.NewPostgresTaskRepo(dsn)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">rdb := redis.NewClient(&amp;redis.Options{
          Addr: redisAddr,
  })
        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
  defer cancel()

  if err := rdb.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
         log.Fatal("redis connection failed:", err)
  }</span>
        <span class="cov0" title="0">cache := repositories.NewRedisTaskRepository(rdb)


        service := services.NewTaskService(repo, cache)
        server := &amp;TaskServer{service: service}

        lis, err := net.Listen("tcp", ":"+port)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to listen: %v", err)
        }</span>

        <span class="cov0" title="0">grpcServer := grpc.NewServer()
        pb.RegisterTaskServiceServer(grpcServer, server)

        log.Printf("gRPC server listening on %s", port)
        if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to serve: %v", err)
        }</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "log"
        "os"
        "time"

        "github.com/segmentio/kafka-go"
        "github.com/spf13/viper"
)

func initConfig() <span class="cov0" title="0">{
        viper.SetEnvPrefix("CHECKLIST")
        viper.AutomaticEnv()
}</span>

func main() <span class="cov0" title="0">{
        initConfig()

        broker := viper.GetString("KAFKA_BROKER")
        topic := viper.GetString("KAFKA_TOPIC")
        logFile := viper.GetString("KAFKA_LOG_FILE")

        if broker == "" || topic == "" || logFile == "" </span><span class="cov0" title="0">{
                log.Fatal("KAFKA_BROKER, KAFKA_TOPIC or KAFKA_LOG_FILE is not configured")
        }</span>

        <span class="cov0" title="0">file, err := os.OpenFile(logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to open log file: %v", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        logger := log.New(file, "", log.LstdFlags)
        logger.Println("Kafka Logger started")

        r := kafka.NewReader(kafka.ReaderConfig{
                Brokers: []string{broker},
                Topic:   topic,
                GroupID: "kafka-logger-group",
        })

        for </span><span class="cov0" title="0">{
                m, err := r.ReadMessage(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("error reading message: %v\n", err)
                        continue</span>
                }

                <span class="cov0" title="0">logger.Printf("[%s] %s\n", time.Now().Format(time.RFC3339), string(m.Value))</span>
        }
}</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.11
//         protoc        v3.21.12
// source: internal/app/pb/task.proto

package pb

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Task struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Title         string                 `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
        Content       string                 `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
        Done          bool                   `protobuf:"varint,4,opt,name=done,proto3" json:"done,omitempty"`
        CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Task) Reset() <span class="cov0" title="0">{
        *x = Task{}
        mi := &amp;file_internal_app_pb_task_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Task) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Task) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Task) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_app_pb_task_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Task.ProtoReflect.Descriptor instead.
func (*Task) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_app_pb_task_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Task) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Task) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Task) GetContent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Task) GetDone() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Done
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Task) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateTaskRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Title         string                 `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
        Content       string                 `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateTaskRequest) Reset() <span class="cov0" title="0">{
        *x = CreateTaskRequest{}
        mi := &amp;file_internal_app_pb_task_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateTaskRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateTaskRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateTaskRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_app_pb_task_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateTaskRequest.ProtoReflect.Descriptor instead.
func (*CreateTaskRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_app_pb_task_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CreateTaskRequest) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateTaskRequest) GetContent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type TaskResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Task          *Task                  `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TaskResponse) Reset() <span class="cov0" title="0">{
        *x = TaskResponse{}
        mi := &amp;file_internal_app_pb_task_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TaskResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TaskResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TaskResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_app_pb_task_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TaskResponse.ProtoReflect.Descriptor instead.
func (*TaskResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_app_pb_task_proto_rawDescGZIP(), []int{2}
}</span>

func (x *TaskResponse) GetTask() *Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Task
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type TaskIDRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TaskIDRequest) Reset() <span class="cov0" title="0">{
        *x = TaskIDRequest{}
        mi := &amp;file_internal_app_pb_task_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TaskIDRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TaskIDRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TaskIDRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_app_pb_task_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TaskIDRequest.ProtoReflect.Descriptor instead.
func (*TaskIDRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_app_pb_task_proto_rawDescGZIP(), []int{3}
}</span>

func (x *TaskIDRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type StatusResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Status        string                 `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatusResponse) Reset() <span class="cov0" title="0">{
        *x = StatusResponse{}
        mi := &amp;file_internal_app_pb_task_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatusResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatusResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatusResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_app_pb_task_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatusResponse.ProtoReflect.Descriptor instead.
func (*StatusResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_app_pb_task_proto_rawDescGZIP(), []int{4}
}</span>

func (x *StatusResponse) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type TaskListResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Tasks         []*Task                `protobuf:"bytes,1,rep,name=tasks,proto3" json:"tasks,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TaskListResponse) Reset() <span class="cov0" title="0">{
        *x = TaskListResponse{}
        mi := &amp;file_internal_app_pb_task_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TaskListResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TaskListResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TaskListResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_app_pb_task_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TaskListResponse.ProtoReflect.Descriptor instead.
func (*TaskListResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_app_pb_task_proto_rawDescGZIP(), []int{5}
}</span>

func (x *TaskListResponse) GetTasks() []*Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tasks
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_internal_app_pb_task_proto protoreflect.FileDescriptor

const file_internal_app_pb_task_proto_rawDesc = "" +
        "\n" +
        "\x1ainternal/app/pb/task.proto\x12\tchecklist\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/empty.proto\"\x95\x01\n" +
        "\x04Task\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x14\n" +
        "\x05title\x18\x02 \x01(\tR\x05title\x12\x18\n" +
        "\acontent\x18\x03 \x01(\tR\acontent\x12\x12\n" +
        "\x04done\x18\x04 \x01(\bR\x04done\x129\n" +
        "\n" +
        "created_at\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\"C\n" +
        "\x11CreateTaskRequest\x12\x14\n" +
        "\x05title\x18\x01 \x01(\tR\x05title\x12\x18\n" +
        "\acontent\x18\x02 \x01(\tR\acontent\"3\n" +
        "\fTaskResponse\x12#\n" +
        "\x04task\x18\x01 \x01(\v2\x0f.checklist.TaskR\x04task\"\x1f\n" +
        "\rTaskIDRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"(\n" +
        "\x0eStatusResponse\x12\x16\n" +
        "\x06status\x18\x01 \x01(\tR\x06status\"9\n" +
        "\x10TaskListResponse\x12%\n" +
        "\x05tasks\x18\x01 \x03(\v2\x0f.checklist.TaskR\x05tasks2\x8b\x02\n" +
        "\vTaskService\x12?\n" +
        "\x06Create\x12\x1c.checklist.CreateTaskRequest\x1a\x17.checklist.TaskResponse\x12;\n" +
        "\x04List\x12\x16.google.protobuf.Empty\x1a\x1b.checklist.TaskListResponse\x12=\n" +
        "\x06Delete\x12\x18.checklist.TaskIDRequest\x1a\x19.checklist.StatusResponse\x12?\n" +
        "\bMarkDone\x12\x18.checklist.TaskIDRequest\x1a\x19.checklist.StatusResponseB\aZ\x05./;pbb\x06proto3"

var (
        file_internal_app_pb_task_proto_rawDescOnce sync.Once
        file_internal_app_pb_task_proto_rawDescData []byte
)

func file_internal_app_pb_task_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_internal_app_pb_task_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_internal_app_pb_task_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_internal_app_pb_task_proto_rawDesc), len(file_internal_app_pb_task_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_internal_app_pb_task_proto_rawDescData</span>
}

var file_internal_app_pb_task_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_internal_app_pb_task_proto_goTypes = []any{
        (*Task)(nil),                  // 0: checklist.Task
        (*CreateTaskRequest)(nil),     // 1: checklist.CreateTaskRequest
        (*TaskResponse)(nil),          // 2: checklist.TaskResponse
        (*TaskIDRequest)(nil),         // 3: checklist.TaskIDRequest
        (*StatusResponse)(nil),        // 4: checklist.StatusResponse
        (*TaskListResponse)(nil),      // 5: checklist.TaskListResponse
        (*timestamppb.Timestamp)(nil), // 6: google.protobuf.Timestamp
        (*emptypb.Empty)(nil),         // 7: google.protobuf.Empty
}
var file_internal_app_pb_task_proto_depIdxs = []int32{
        6, // 0: checklist.Task.created_at:type_name -&gt; google.protobuf.Timestamp
        0, // 1: checklist.TaskResponse.task:type_name -&gt; checklist.Task
        0, // 2: checklist.TaskListResponse.tasks:type_name -&gt; checklist.Task
        1, // 3: checklist.TaskService.Create:input_type -&gt; checklist.CreateTaskRequest
        7, // 4: checklist.TaskService.List:input_type -&gt; google.protobuf.Empty
        3, // 5: checklist.TaskService.Delete:input_type -&gt; checklist.TaskIDRequest
        3, // 6: checklist.TaskService.MarkDone:input_type -&gt; checklist.TaskIDRequest
        2, // 7: checklist.TaskService.Create:output_type -&gt; checklist.TaskResponse
        5, // 8: checklist.TaskService.List:output_type -&gt; checklist.TaskListResponse
        4, // 9: checklist.TaskService.Delete:output_type -&gt; checklist.StatusResponse
        4, // 10: checklist.TaskService.MarkDone:output_type -&gt; checklist.StatusResponse
        7, // [7:11] is the sub-list for method output_type
        3, // [3:7] is the sub-list for method input_type
        3, // [3:3] is the sub-list for extension type_name
        3, // [3:3] is the sub-list for extension extendee
        0, // [0:3] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_internal_app_pb_task_proto_init() }</span>
func file_internal_app_pb_task_proto_init() <span class="cov0" title="0">{
        if File_internal_app_pb_task_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_internal_app_pb_task_proto_rawDesc), len(file_internal_app_pb_task_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   6,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_internal_app_pb_task_proto_goTypes,
                DependencyIndexes: file_internal_app_pb_task_proto_depIdxs,
                MessageInfos:      file_internal_app_pb_task_proto_msgTypes,
        }.Build()
        File_internal_app_pb_task_proto = out.File
        file_internal_app_pb_task_proto_goTypes = nil
        file_internal_app_pb_task_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: internal/app/pb/task.proto

package pb

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        TaskService_Create_FullMethodName   = "/checklist.TaskService/Create"
        TaskService_List_FullMethodName     = "/checklist.TaskService/List"
        TaskService_Delete_FullMethodName   = "/checklist.TaskService/Delete"
        TaskService_MarkDone_FullMethodName = "/checklist.TaskService/MarkDone"
)

// TaskServiceClient is the client API for TaskService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TaskServiceClient interface {
        Create(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*TaskResponse, error)
        List(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TaskListResponse, error)
        Delete(ctx context.Context, in *TaskIDRequest, opts ...grpc.CallOption) (*StatusResponse, error)
        MarkDone(ctx context.Context, in *TaskIDRequest, opts ...grpc.CallOption) (*StatusResponse, error)
}

type taskServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewTaskServiceClient(cc grpc.ClientConnInterface) TaskServiceClient <span class="cov0" title="0">{
        return &amp;taskServiceClient{cc}
}</span>

func (c *taskServiceClient) Create(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*TaskResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(TaskResponse)
        err := c.cc.Invoke(ctx, TaskService_Create_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) List(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TaskListResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(TaskListResponse)
        err := c.cc.Invoke(ctx, TaskService_List_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) Delete(ctx context.Context, in *TaskIDRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, TaskService_Delete_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) MarkDone(ctx context.Context, in *TaskIDRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, TaskService_MarkDone_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// TaskServiceServer is the server API for TaskService service.
// All implementations must embed UnimplementedTaskServiceServer
// for forward compatibility.
type TaskServiceServer interface {
        Create(context.Context, *CreateTaskRequest) (*TaskResponse, error)
        List(context.Context, *emptypb.Empty) (*TaskListResponse, error)
        Delete(context.Context, *TaskIDRequest) (*StatusResponse, error)
        MarkDone(context.Context, *TaskIDRequest) (*StatusResponse, error)
        mustEmbedUnimplementedTaskServiceServer()
}

// UnimplementedTaskServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTaskServiceServer struct{}

func (UnimplementedTaskServiceServer) Create(context.Context, *CreateTaskRequest) (*TaskResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method Create not implemented")
}</span>
func (UnimplementedTaskServiceServer) List(context.Context, *emptypb.Empty) (*TaskListResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method List not implemented")
}</span>
func (UnimplementedTaskServiceServer) Delete(context.Context, *TaskIDRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method Delete not implemented")
}</span>
func (UnimplementedTaskServiceServer) MarkDone(context.Context, *TaskIDRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method MarkDone not implemented")
}</span>
func (UnimplementedTaskServiceServer) mustEmbedUnimplementedTaskServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedTaskServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeTaskServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskServiceServer will
// result in compilation errors.
type UnsafeTaskServiceServer interface {
        mustEmbedUnimplementedTaskServiceServer()
}

func RegisterTaskServiceServer(s grpc.ServiceRegistrar, srv TaskServiceServer) <span class="cov0" title="0">{
        // If the following call panics, it indicates UnimplementedTaskServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;TaskService_ServiceDesc, srv)</span>
}

func _TaskService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateTaskRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).Create(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_Create_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).Create(ctx, req.(*CreateTaskRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).List(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_List_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).List(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(TaskIDRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).Delete(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_Delete_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).Delete(ctx, req.(*TaskIDRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_MarkDone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(TaskIDRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).MarkDone(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_MarkDone_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).MarkDone(ctx, req.(*TaskIDRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// TaskService_ServiceDesc is the grpc.ServiceDesc for TaskService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "checklist.TaskService",
        HandlerType: (*TaskServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Create",
                        Handler:    _TaskService_Create_Handler,
                },
                {
                        MethodName: "List",
                        Handler:    _TaskService_List_Handler,
                },
                {
                        MethodName: "Delete",
                        Handler:    _TaskService_Delete_Handler,
                },
                {
                        MethodName: "MarkDone",
                        Handler:    _TaskService_MarkDone_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "internal/app/pb/task.proto",
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package repositories

import (
        "database/sql"
        "time"

        "github.com/google/uuid"
        "github.com/kalpovskii/checklist/internal/app/models"
        _ "github.com/lib/pq"
)

type TaskRepository interface {
        Create(task *models.Task) error
        List() ([]models.Task, error)
        Delete(id uuid.UUID) error
        MarkDone(id uuid.UUID) error
}

type PostgresTaskRepo struct {
        db *sql.DB
}

func NewPostgresTaskRepo(dsn string) (*PostgresTaskRepo, error) <span class="cov0" title="0">{
        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = db.Exec(`
                CREATE TABLE IF NOT EXISTS tasks (
                        id UUID PRIMARY KEY,
                        title TEXT NOT NULL,
                        content TEXT,
                        done BOOLEAN DEFAULT FALSE,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
        `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;PostgresTaskRepo{db: db}, nil</span>
}

func (r *PostgresTaskRepo) Create(task *models.Task) error <span class="cov0" title="0">{
        task.ID = uuid.New()
        task.CreatedAt = time.Now()
        _, err := r.db.Exec("INSERT INTO tasks (id, title, content, done, created_at) VALUES ($1, $2, $3, $4, $5)",
                task.ID, task.Title, task.Content, task.Done, task.CreatedAt)
        return err
}</span>

func (r *PostgresTaskRepo) List() ([]models.Task, error) <span class="cov0" title="0">{
        rows, err := r.db.Query("SELECT id, title, content, done, created_at FROM tasks")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var tasks []models.Task
        for rows.Next() </span><span class="cov0" title="0">{
                var t models.Task
                err := rows.Scan(&amp;t.ID, &amp;t.Title, &amp;t.Content, &amp;t.Done, &amp;t.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">tasks = append(tasks, t)</span>
        }
        <span class="cov0" title="0">return tasks, nil</span>
}

func (r *PostgresTaskRepo) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        _, err := r.db.Exec("DELETE FROM tasks WHERE id = $1", id)
        return err
}</span>

func (r *PostgresTaskRepo) MarkDone(id uuid.UUID) error <span class="cov0" title="0">{
        _, err := r.db.Exec("UPDATE tasks SET done = TRUE WHERE id = $1", id)
        return err
}</pre>
		
		<pre class="file" id="file6" style="display: none">package repositories

import (
        "context"
        "encoding/json"
        "time"

        "github.com/kalpovskii/checklist/internal/app/models"
        "github.com/redis/go-redis/v9"
)

type TaskCache interface {
        GetTask(ctx context.Context, id string) (*models.Task, error)
        SetTask(ctx context.Context, task *models.Task, ttl time.Duration) error

        GetTaskList(ctx context.Context) ([]models.Task, error)
        SetTaskList(ctx context.Context, tasks []models.Task, ttl time.Duration) error

        DeleteTask(ctx context.Context, id string) error
        DeleteTaskList(ctx context.Context) error
}

type RedisTaskRepository struct {
        rdb *redis.Client
}

func NewRedisTaskRepository(rdb *redis.Client) *RedisTaskRepository <span class="cov0" title="0">{
        return &amp;RedisTaskRepository{rdb: rdb}
}</span>

func taskKey(id string) string <span class="cov0" title="0">{
        return "task:" + id
}</span>

const taskListKey = "tasks:list"

func (r *RedisTaskRepository) GetTask(
        ctx context.Context,
        id string,
) (*models.Task, error) <span class="cov0" title="0">{

        val, err := r.rdb.Get(ctx, taskKey(id)).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return nil, nil // cache miss
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var task models.Task
        if err := json.Unmarshal([]byte(val), &amp;task); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;task, nil</span>
}

func (r *RedisTaskRepository) SetTask(
        ctx context.Context,
        task *models.Task,
        ttl time.Duration,
) error <span class="cov0" title="0">{

        data, err := json.Marshal(task)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return r.rdb.Set(ctx, taskKey(task.ID.String()), data, ttl).Err()</span>
}

func (r *RedisTaskRepository) DeleteTask(ctx context.Context, id string) error <span class="cov0" title="0">{
        return r.rdb.Del(ctx, taskKey(id)).Err()
}</span>

func (r *RedisTaskRepository) DeleteTaskList(ctx context.Context) error <span class="cov0" title="0">{
        return r.rdb.Del(ctx, taskListKey).Err()
}</span>

func (r *RedisTaskRepository) GetTaskList(ctx context.Context) ([]models.Task, error) <span class="cov0" title="0">{
        val, err := r.rdb.Get(ctx, taskListKey).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var tasks []models.Task
        if err := json.Unmarshal([]byte(val), &amp;tasks); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}

func (r *RedisTaskRepository) SetTaskList(
        ctx context.Context,
        tasks []models.Task,
        ttl time.Duration,
) error <span class="cov0" title="0">{

        data, err := json.Marshal(tasks)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return r.rdb.Set(ctx, taskListKey, data, ttl).Err()</span>
}

</pre>
		
		<pre class="file" id="file7" style="display: none">package services

import (
        "context"
        "time"

        "github.com/google/uuid"
        "github.com/kalpovskii/checklist/internal/app/models"
        "github.com/kalpovskii/checklist/internal/app/repositories"
)

const (
        taskTTL     = 60 * time.Second
        taskListTTL = 15 * time.Second
)

type TaskService struct {
        repo  repositories.TaskRepository
        cache repositories.TaskCache
}

func NewTaskService(repo repositories.TaskRepository, cache repositories.TaskCache) *TaskService <span class="cov0" title="0">{
        return &amp;TaskService{
                repo:  repo,
                cache: cache,
        }
}</span>

func (s *TaskService) Create(title, content string) (*models.Task, error) <span class="cov0" title="0">{
        task := &amp;models.Task{
                Title:   title,
                Content: content,
        }

        if err := s.repo.Create(task); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        _ = s.cache.SetTask(ctx, task, taskTTL)
        _ = s.cache.DeleteTaskList(ctx)

        return task, nil</span>
}

func (s *TaskService) List() ([]models.Task, error) <span class="cov0" title="0">{
        ctx := context.Background()

        if tasks, err := s.cache.GetTaskList(ctx); err == nil &amp;&amp; tasks != nil </span><span class="cov0" title="0">{
                return tasks, nil
        }</span>

        <span class="cov0" title="0">tasks, err := s.repo.List()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_ = s.cache.SetTaskList(ctx, tasks, taskListTTL)

        return tasks, nil</span>
}

func (s *TaskService) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        if err := s.repo.Delete(id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        _ = s.cache.DeleteTask(ctx, id.String())
        _ = s.cache.DeleteTaskList(ctx)

        return nil</span>
}

func (s *TaskService) MarkDone(id uuid.UUID) error <span class="cov0" title="0">{
        if err := s.repo.MarkDone(id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        _ = s.cache.DeleteTask(ctx, id.String())
        _ = s.cache.DeleteTaskList(ctx)

        return nil</span>
}</pre>
		
		<pre class="file" id="file8" style="display: none">package kafka

import (
        "context"
        "log"
        "time"

        "github.com/segmentio/kafka-go"
)

type Producer struct {
        writer *kafka.Writer
}

func NewProducer(broker, topic string) *Producer <span class="cov0" title="0">{
        return &amp;Producer{
                writer: &amp;kafka.Writer{
                        Addr:     kafka.TCP(broker),
                        Topic:    topic,
                        Balancer: &amp;kafka.LeastBytes{},
                },
        }
}</span>

func (p *Producer) SendEvent(action string) <span class="cov0" title="0">{
        msg := kafka.Message{
                Key:   []byte(time.Now().Format(time.RFC3339Nano)),
                Value: []byte(action),
                Time:  time.Now(),
        }

        if err := p.writer.WriteMessages(context.Background(), msg); err != nil </span><span class="cov0" title="0">{
                log.Println("failed to write kafka message:", err)
        }</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
